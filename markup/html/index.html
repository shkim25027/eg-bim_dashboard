<!doctype html>
<html lang="ko">
  <head>
    @@include("_include/_head.html")
  </head>
  <body>
    <div class="wrap">
      @@include("_include/_header.html")
      <!-- container -->
      <div class="container">
        <div class="main-contents">
          <div class="main-grid">
            <section class="card col">
              <div class="inner">
                <div class="card-header">연간 총 판매 실적</div>
                <div class="card-body">
                  <div class="stat-row accrue">
                    <div class="label-box">
                      <span class="label">누적 판매수</span>
                      <span class="change-up">전월대비 <em>84</em></span>
                    </div>
                    <div>
                      <span class="big-num">475</span
                      ><span class="unit">copy</span>
                    </div>
                  </div>
                  <!-- // stat-row -->
                  <div class="stat-row">
                    <div class="label-box">
                      <span class="label">누적 판매액</span>
                      <span class="change">전월대비 <em>00</em></span>
                    </div>
                    <div>
                      <span class="big-num">0.0</span
                      ><span class="unit">억</span>
                    </div>
                  </div>
                  <!-- // stat-row -->
                  <div class="stat-row">
                    <div class="label-box">
                      <span class="label">목표 달성률</span>
                      <span class="change-up">전월대비 <em>1p</em></span>
                    </div>
                    <div>
                      <span class="big-num">95</span><span class="unit">%</span>
                    </div>
                  </div>
                  <!-- // stat-row -->
                </div>
                <!-- // card-body -->
              </div>
              <!-- // inner -->
              <div class="chart-wrap">
                <canvas id="yearly_chart"></canvas>
              </div>
              <!-- // chart-warp -->
            </section>
            <section class="card">
              <div class="card-header">연간 개인별 판매 실적</div>
              <div class="card-body"></div>
            </section>
            <section class="card">
              <div class="card-header">연간 영업 판매 현황</div>
              <div class="card-body"></div>
            </section>
            <section class="card">
              <div class="inner">
                <div class="card-header">8월 판매 실적</div>
                <div class="card-body">
                  <div class="stat-row month">
                    <div class="label-box">
                      <span class="label">당월 판매수</span>
                      <span class="change-down">전주대비 <em>70</em></span>
                    </div>
                    <div>
                      <span class="big-num">99</span
                      ><span class="unit">copy</span>
                    </div>
                  </div>

                  <div class="stat-row">
                    <div class="label-box">
                      <span class="label">당월 매출액</span>
                      <span class="change">전주대비 <em>00</em></span>
                    </div>
                    <div>
                      <span class="big-num">0.0</span
                      ><span class="unit">억</span>
                    </div>
                  </div>

                  <div class="stat-row">
                    <div class="label-box">
                      <span class="label">목표 달성률</span>
                      <span class="change-up">전주대비 <em>1p</em></span>
                    </div>
                    <div>
                      <span class="big-num">95</span><span class="unit">%</span>
                    </div>
                  </div>
                </div>
              </div>
            </section>
          </div>
          <div class="main-weekly"></div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        // ---------------------------
        // 유틸 / 공통
        // ---------------------------
        const charts = {}; // 차트 인스턴스 저장소

        function safeGrad(ctx, area, colors, horizontal = false) {
          // 안전하게 area가 준비되지 않았으면 단일 컬러 리턴
          if (!area || area.left === undefined) return colors[0].color;
          const { left, right, top, bottom } = area;
          // horizontal true => 세로 그라데이션(위->아래), 아니면 가로(왼->오)
          const g = horizontal
            ? ctx.createLinearGradient(0, top, 0, bottom)
            : ctx.createLinearGradient(left, 0, right, 0);
          colors.forEach((c) => g.addColorStop(c.stop, c.color));
          return g;
        }

        const theme = {
          gold: [
            { stop: 0, color: "#918050" },
            { stop: 0.34, color: "#968860" },
            { stop: 0.5, color: "#8C7D50" },
            { stop: 1, color: "#6D5A21" },
          ],
        };

        const labels12 = Array.from({ length: 12 }, (_, i) => String(i + 1));

        // ---------------------------
        // 플러그인 그룹
        // ---------------------------

        const valuePlugin = {
          id: "valuePlugin",
          afterDatasetsDraw(chart) {
            const { ctx } = chart;
            const isHorizontal = chart.config.options?.indexAxis === "y";
            ctx.save();
            ctx.font = "bold 13px Arial";
            ctx.textBaseline = "middle";
            chart.data.datasets.forEach((ds, i) => {
              if (ds.type === "line") return;
              const meta = chart.getDatasetMeta(i);
              meta.data.forEach((bar, j) => {
                const v = ds.data[j];
                if (v === null || v === undefined) return;
                if (isHorizontal) {
                  ctx.fillStyle = "#000";
                  ctx.textAlign = "left";
                  ctx.fillText(v, bar.x + 10, bar.y);
                } else {
                  ctx.fillStyle = "#fff";
                  ctx.textAlign = "center";
                  ctx.fillText(v, bar.x, bar.y + 10);
                }
              });
            });
            ctx.restore();
          },
        };

        const highlightXFactory = (label, color = "rgba(255,230,200,0.4)") => ({
          id: `highlightX_${label}`,
          beforeDatasetsDraw(chart) {
            if (!chart.chartArea) return;
            const {
              ctx,
              chartArea,
              scales: { x },
              data,
            } = chart;
            const i = data.labels.indexOf(label);
            if (i === -1) return;
            let w = x.getPixelForValue(i + 1) - x.getPixelForValue(i);
            if (isNaN(w) && i > 0)
              w = x.getPixelForValue(i) - x.getPixelForValue(i - 1);
            ctx.save();
            ctx.fillStyle = color;
            ctx.fillRect(
              x.getPixelForValue(i) - w / 2,
              chartArea.top,
              w,
              chartArea.bottom - chartArea.top
            );
            ctx.restore();
          },
        });

        const hideNullPointsPlugin = {
          id: "hideNullPoints",
          beforeDatasetsDraw(chart) {
            chart.data.datasets.forEach((dataset) => {
              if (dataset.type !== "line") return;
              const data = dataset.data;
              if (!Array.isArray(data)) return;
              // ensure array radii so we can mutate per point
              if (!Array.isArray(dataset.pointRadius)) {
                dataset.pointRadius = data.map(() => dataset.pointRadius || 6);
              }
              if (!Array.isArray(dataset.pointHoverRadius)) {
                dataset.pointHoverRadius = data.map(
                  () => dataset.pointHoverRadius || 8
                );
              }
              dataset.pointRadius = data.map((val, idx) =>
                val === null ? 0 : dataset.pointRadius[idx]
              );
              dataset.pointHoverRadius = data.map((val, idx) =>
                val === null ? 0 : dataset.pointHoverRadius[idx]
              );
            });
          },
        };

        const backgroundPlugin = {
          id: "backgroundBars",
          beforeDatasetsDraw(chart) {
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            const metas = chart.getSortedVisibleDatasetMetas();
            ctx.save();
            metas.forEach((meta) => {
              meta.data.forEach((bar, index) => {
                if (!bar || bar.hidden) return;
                const dataset = chart.data.datasets[meta.index];
                const dataRange = dataset.data[index];
                if (!dataRange || dataRange === null) return;
                const barTop = bar.y - bar.height / 2;
                const barHeight = bar.height;
                const startWeek = Math.floor(dataRange[0]);
                const endWeek = Math.ceil(dataRange[1]);
                for (let i = startWeek; i < endWeek; i++) {
                  const xStart = xAxis.getPixelForValue(i);
                  const xEnd = xAxis.getPixelForValue(i + 1);
                  const width = xEnd - xStart;
                  ctx.fillStyle =
                    i % 2 === 0
                      ? "rgba(240,240,240,0.6)"
                      : "rgba(220,220,220,0.3)";
                  ctx.fillRect(xStart, barTop, width, barHeight);
                }
              });
            });
            ctx.restore();
          },
        };

        const dataLabelsPlugin = {
          id: "customDataLabels",
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            ctx.save();
            ctx.font = "bold 14px sans-serif";
            ctx.fillStyle = "#fff";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            chart.data.datasets.forEach((dataset) => {
              const metaIndex = chart.data.datasets.indexOf(dataset);
              const meta = chart.getDatasetMeta(metaIndex);
              if (!meta || meta.hidden) return;
              meta.data.forEach((bar, index) => {
                const displayValue = dataset.displayValues?.[index];
                if (displayValue == null) return;
                const dataRange = dataset.data[index];
                if (!dataRange) return;
                const endValue = dataRange[1];
                const textX = xAxis.getPixelForValue(endValue) - 10;
                ctx.fillText(displayValue, textX, bar.y);
              });
            });
            ctx.restore();
          },
        };

        function createMixedValuePlugin(padding = 10) {
          return {
            id: "mixedValuePlugin",
            afterDatasetsDraw(chart) {
              const ctx = chart.ctx;
              chart.data.datasets.forEach((dataset, i) => {
                const meta = chart.getDatasetMeta(i);
                if (!meta || !meta.data) return;
                meta.data.forEach((element, index) => {
                  const value = dataset.data[index];
                  if (value === null || value === undefined || value === 0)
                    return;
                  ctx.save();
                  ctx.font = "bold 12px Arial";
                  ctx.textAlign = "center";
                  let xPos, yPos;
                  const textValue = String(value);
                  if (dataset.type === "bar") {
                    ctx.textBaseline = "bottom";
                    xPos = element.x;
                    yPos = element.y - padding;
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 3;
                    ctx.fillStyle = "#000";
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.shadowBlur = 2;
                    ctx.shadowColor = "rgba(0,0,0,0.4)";
                    ctx.strokeText(textValue, xPos, yPos);
                    ctx.shadowBlur = 0;
                    ctx.fillText(textValue, xPos, yPos);
                  } else if (dataset.type === "line") {
                    ctx.textBaseline = "top";
                    xPos = element.x;
                    yPos = element.y - padding - 10;
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 3;
                    ctx.fillStyle = "#FF5C00";
                    ctx.shadowOffsetX = 1;
                    ctx.shadowOffsetY = 1;
                    ctx.shadowBlur = 2;
                    ctx.shadowColor = "rgba(0,0,0,0.5)";
                    ctx.strokeText(textValue, xPos, yPos);
                    ctx.shadowBlur = 0;
                    ctx.fillText(textValue, xPos, yPos);
                  }
                  ctx.restore();
                });
              });
            },
          };
        }

        function createMixedPointGradientPlugin(gradientColors) {
          return {
            id: "mixedPointGradient",
            afterDatasetsDraw(chart) {
              const ctx = chart.ctx;
              chart.data.datasets.forEach((dataset, datasetIndex) => {
                const meta = chart.getDatasetMeta(datasetIndex);
                if (dataset.type !== "line" || !meta || !meta.data) return;
                meta.data.forEach((point, index) => {
                  const { x, y } = point;
                  const radius = Array.isArray(dataset.pointRadius)
                    ? (dataset.pointRadius[index] ?? 7)
                    : (dataset.pointRadius ?? 7);
                  if (radius === 0) return;
                  const gradCenterX = x - radius + 2 * radius * 0.3333;
                  const gradCenterY = y - radius + 2 * radius * 0.3333;
                  const outerRadius = radius * 0.7862;
                  const gradient = ctx.createRadialGradient(
                    gradCenterX,
                    gradCenterY,
                    0,
                    gradCenterX,
                    gradCenterY,
                    outerRadius
                  );
                  (
                    gradientColors || [
                      { stop: 0.1475, color: "#FFBB89" },
                      { stop: 0.5805, color: "#E5690D" },
                      { stop: 0.9277, color: "#AE3607" },
                    ]
                  ).forEach((c) => gradient.addColorStop(c.stop, c.color));
                  ctx.save();
                  ctx.beginPath();
                  ctx.arc(x, y, radius, 0, Math.PI * 2);
                  ctx.fillStyle = gradient;
                  ctx.fill();
                  ctx.strokeStyle = "rgba(255,255,255,0.9)";
                  ctx.lineWidth = 2.5;
                  ctx.stroke();
                  ctx.restore();
                });
              });
            },
          };
        }

        // ---------------------------
        // 차트 생성 헬퍼
        // ---------------------------
        function createSafeChart(ctxOrId, config, name) {
          // ctxOrId : element id string or canvas element
          let el;
          if (typeof ctxOrId === "string") {
            el = document.getElementById(ctxOrId);
          } else {
            el = ctxOrId;
          }
          if (!el) {
            console.warn("[createSafeChart] canvas not found:", ctxOrId);
            return null;
          }
          // destroy existing
          if (charts[el.id]) {
            try {
              charts[el.id].destroy();
            } catch (e) {
              /* ignore */
            }
          }
          const c = new Chart(el, config);
          charts[el.id] = c;
          return c;
        }

        // ---------------------------
        // 전체 초기화 (모든 차트)
        // ---------------------------
        function initCharts() {
          // c2 - 복합 막대 + 라인
          createSafeChart("yearly_chart", {
            type: "bar",
            data: {
              labels: labels12,
              datasets: [
                {
                  type: "line",
                  order: 1,
                  data: [
                    73,
                    75,
                    104,
                    128,
                    207,
                    280,
                    376,
                    475,
                    null,
                    null,
                    null,
                    null,
                  ],
                  borderColor: "#FF5C00",
                  borderWidth: 4,
                  pointRadius: 7,
                  tension: 0,
                  fill: false,
                },
                {
                  type: "bar",
                  order: 2,
                  data: [73, 2, 29, 24, 79, 73, 96, 99, null, null, null, null],
                  backgroundColor: (ctx) =>
                    safeGrad(ctx.chart.ctx, ctx.chart.chartArea, theme.gold),
                  borderRadius: { topLeft: 2, topRight: 2 },
                },
              ],
            },
            options: {
              responsive: true,
              plugins: { legend: { position: "top" } },
            },
            plugins: [
              createMixedValuePlugin(12),
              createMixedPointGradientPlugin(),
              highlightXFactory("11"),
              hideNullPointsPlugin,
            ],
          });
        } // initCharts 끝

        // ---------------------------
        // 리사이즈 데바운스 및 리프레시
        // ---------------------------
        function debounce(fn, wait = 120) {
          let t;
          return function (...args) {
            clearTimeout(t);
            t = setTimeout(() => fn.apply(this, args), wait);
          };
        }

        const handleResize = debounce(() => {
          Object.values(charts).forEach((c) => {
            try {
              c.resize();
              c.update();
            } catch (e) {
              /* ignore */
            }
          });
        }, 120);

        window.addEventListener("resize", handleResize);

        // ---------------------------
        // 초기 실행
        // ---------------------------
        // DOM ready
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", initCharts);
        } else {
          initCharts();
        }

        // 외부에서 재초기화 가능하게 노출
        window.__CHARTS = {
          charts,
          init: initCharts,
          destroyAll: () => {
            Object.keys(charts).forEach((k) => {
              try {
                charts[k].destroy();
              } catch (e) {}
              delete charts[k];
            });
          },
        };
      })();
    </script>
  </body>
</html>
