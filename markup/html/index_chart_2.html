<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chart.js Examples</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <style>
      body {
        padding: 20px;
        font-family: Arial, sans-serif;
      }
      section {
        margin-bottom: 40px;
        padding: 20px;
        background: #f5f5f5;
      }
      canvas {
        max-height: 400px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="container">
        <section>
          <h2>세로 막대 차트</h2>
          <div>
            <canvas id="chart-columnLine"></canvas>
          </div>
        </section>
        <section>
          <h2>세로 막대 + 라인 차트</h2>
          <div>
            <canvas id="chart-mixed"></canvas>
          </div>
        </section>
        <section class="sales">
          <h2>라인+영역 차트</h2>
          <div>
            <canvas id="chart-linearea"></canvas>
          </div>
        </section>
        <section>
          <h2>가로 막대 차트</h2>
          <div><canvas id="chart-bar"></canvas></div>
        </section>
        <section>
          <h2>도넛 차트</h2>
          <div>
            <canvas id="chart-doughnut"></canvas>
          </div>
        </section>
      </div>
    </div>

    <script>
      // ---------------------------
      // 공통 색상 그라데이션
      // ---------------------------
      const gradientColors = [
        { stop: 0, color: "#918050" },
        { stop: 0.3399, color: "#968860" },
        { stop: 0.4981, color: "#8C7D50" },
        { stop: 1, color: "#6D5A21" },
      ];

      // ---------------------------
      // 공통: 막대 그라데이션 생성
      // ---------------------------
      function createGradient(ctx, bar, colors, isHorizontal = false) {
        if (!bar || (isHorizontal ? !bar.height : !bar.width))
          return colors[0].color;
        const gradient = isHorizontal
          ? ctx.createLinearGradient(0, bar.y, 0, bar.y + bar.height)
          : ctx.createLinearGradient(bar.x, 0, bar.x + bar.width, 0);
        colors.forEach((c) => gradient.addColorStop(c.stop, c.color));
        return gradient;
      }

      // ---------------------------
      // 공통: 값 표시 플러그인 (세로/가로 구분)
      // ---------------------------
      function createValuePlugin(isHorizontal = false, padding = 0) {
        return {
          id: "valuePlugin",
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;

            // ✨ 텍스트 그림자(Text Shadow) 설정
            ctx.shadowColor = "rgba(255, 255, 255, 0.6)"; // 흰색 그림자로 설정 (값이 잘 보이도록)
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            chart.data.datasets.forEach((dataset, i) => {
              chart.getDatasetMeta(i).data.forEach((bar, index) => {
                const value = dataset.data[index];

                // 0이거나 값이 없으면 표시 안 함
                if (!value || value === 0) return;

                ctx.fillStyle = "#000";
                ctx.font = "bold 14px Arial";

                let xPos, yPos;

                if (isHorizontal) {
                  // 가로 막대: 막대 끝(오른쪽)에 표시
                  ctx.textAlign = "left";
                  ctx.textBaseline = "middle";
                  xPos = bar.x + bar.width + padding;
                  yPos = bar.y + bar.height / 2;
                } else {
                  // 세로 막대: 막대 끝(위쪽)에 표시
                  ctx.textAlign = "center";
                  ctx.textBaseline = "bottom";
                  xPos = bar.x;
                  yPos = bar.y - padding;
                }

                ctx.fillText(value, xPos, yPos);
              });
            });

            // ⚠️ 중요: 그림자 초기화
            ctx.shadowColor = "rgba(0, 0, 0, 0)";
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
          },
        };
      }

      // ---------------------------
      // 복합 차트용: 막대+라인 값 표시 플러그인
      // ---------------------------
      function createMixedValuePlugin(padding = 10) {
        return {
          id: "mixedValuePlugin",
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;
            chart.data.datasets.forEach((dataset, i) => {
              const meta = chart.getDatasetMeta(i);

              meta.data.forEach((element, index) => {
                const value = dataset.data[index];
                if (!value || value === 0) return;

                ctx.font = "bold 12px Arial";
                ctx.textAlign = "center";

                let xPos, yPos;

                // 막대 차트인 경우
                if (dataset.type === "bar") {
                  ctx.fillStyle = "#000"; // 막대는 검은색
                  ctx.textBaseline = "bottom";
                  xPos = element.x;
                  yPos = element.y - padding;
                }
                // 라인 차트인 경우
                else if (dataset.type === "line") {
                  ctx.fillStyle = "#FF5C00"; // 라인은 오렌지색
                  ctx.textBaseline = "top";
                  xPos = element.x;
                  yPos = element.y - padding - 5; // 라인 포인트 위쪽
                }

                ctx.fillText(value, xPos, yPos);
              });
            });
          },
        };
      }

      // 복합 차트용 포인트 그라데이션 플러그인 (보더 추가)
      const mixedPointGradientPlugin = {
        id: "mixedPointGradient",
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const meta = chart.getDatasetMeta(datasetIndex);
            if (dataset.type !== "line") return;

            meta.data.forEach((point, index) => {
              const { x, y } = point;
              const radius = dataset.pointRadius || 4;

              // -----------------------------------------------------
              // ✨ CSS 스타일을 캔버스 API로 변환 (기존 그라데이션 로직)
              // -----------------------------------------------------
              const gradCenterX = x - radius + 2 * radius * 0.3333;
              const gradCenterY = y - radius + 2 * radius * 0.3333;
              const outerRadius = radius * 0.7862;

              const gradient = ctx.createRadialGradient(
                gradCenterX,
                gradCenterY,
                0,
                gradCenterX,
                gradCenterY,
                outerRadius
              );

              gradient.addColorStop(0.1475, "#FFBB89");
              gradient.addColorStop(0.5805, "#E5690D");
              gradient.addColorStop(0.9277, "#AE3607");
              // -----------------------------------------------------

              // 포인트 다시 그리기
              ctx.save();
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, 2 * Math.PI);

              // 1. 그라데이션 채우기
              ctx.fillStyle = gradient;
              ctx.fill();

              // 2. ✨ 흰색 반투명 보더(Border) 그리기
              ctx.strokeStyle = "rgba(255, 255, 255, 0.8)"; // 흰색, 70% 투명도
              ctx.lineWidth = 2; // 보더 두께 (원하는 두께로 조절)
              ctx.stroke(); // 보더 그리기

              ctx.restore();
            });
          });
        },
      };

      // ---------------------------
      // 세로 막대 차트
      // ---------------------------
      const columnCtx = document
        .getElementById("chart-columnLine")
        .getContext("2d");
      new Chart(columnCtx, {
        type: "bar",
        data: {
          labels: [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
          ],
          datasets: [
            {
              label: "판매량",
              data: [0, 0, 0, 0, 0, 0, 0, 0, 100, 1000, 100, 0],
              backgroundColor: function (context) {
                const chart = context.chart;
                const meta = chart.getDatasetMeta(context.datasetIndex);
                const bar = meta.data[context.dataIndex];
                return createGradient(chart.ctx, bar, gradientColors);
              },
              borderRadius: {
                topLeft: 2,
                topRight: 2,
                bottomLeft: 0,
                bottomRight: 0,
              },
              borderSkipped: false,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: { enabled: true },
          },
          scales: {
            y: {
              display: false,
              suggestedMax: 1200,
              beginAtZero: true,
              grid: { color: "#eee" },
              ticks: {
                display: false,
              },
            },
            x: {
              grid: {
                drawTicks: false,
              },
              ticks: {
                color: function (context) {
                  if (context.tick.label === "11") {
                    return "#121212";
                  }
                  return "rgba(18, 18, 18, 0.60)";
                },
                font: function (context) {
                  if (context.tick.label === "11") {
                    return {
                      weight: "bold",
                      size: 12,
                    };
                  }
                  return {
                    weight: "normal",
                    size: 12,
                  };
                },
              },
              border: {
                display: true,
                dash: [3, 3],
                color: "rgba(0, 0, 0, 0.30)",
                width: 1,
              },
            },
          },
        },
        plugins: [createValuePlugin(false, 10)],
      });

      // ---------------------------
      // 세로 막대 + 라인 차트 (복합)
      // ---------------------------
      const mixedCtx = document.getElementById("chart-mixed").getContext("2d");

      new Chart(mixedCtx, {
        type: "bar",
        data: {
          labels: [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
          ],
          datasets: [
            {
              type: "bar",
              label: "판매량",
              data: [
                300, 400, 350, 450, 500, 320, 280, 600, 490, 350, 450, 520,
              ],
              backgroundColor: function (context) {
                const chart = context.chart;
                const meta = chart.getDatasetMeta(context.datasetIndex);
                const bar = meta.data[context.dataIndex];
                return createGradient(chart.ctx, bar, gradientColors);
              },
              borderRadius: {
                topLeft: 2,
                topRight: 2,
                bottomLeft: 0,
                bottomRight: 0,
              },
              borderSkipped: false,
              yAxisID: "y",
              order: 2, // 막대를 뒤로
            },
            {
              type: "line",
              label: "매출",
              data: [
                250, 380, 320, 420, 480, 300, 260, 580, 470, 330, 430, 500,
              ],
              borderColor: "#FF5C00",
              backgroundColor: "rgba(36,148,115,0.1)",
              borderWidth: 2,
              tension: 0,
              pointBackgroundColor: function (context) {
                const element = context.element;
                if (!element || !element.x || !element.y || !element.radius)
                  return "#249473";
                const { x, y, radius } = element;
                const grad = context.chart.ctx.createRadialGradient(
                  x,
                  y,
                  0,
                  x,
                  y,
                  radius
                );
                grad.addColorStop(0.0648, "#4FFFCB");
                grad.addColorStop(0.3914, "#249473");
                return grad;
              },
              pointRadius: 4,
              pointHoverRadius: 6,
              yAxisID: "y",
              order: 1, // 라인을 앞으로
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true },
            tooltip: { enabled: true },
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: { color: "#eee" },
              ticks: {
                color: "rgba(18, 18, 18, 0.60)",
              },
            },
            x: {
              grid: {
                drawTicks: false,
              },
              ticks: {
                color: function (context) {
                  if (context.tick.label === "11") {
                    return "#121212";
                  }
                  return "rgba(18, 18, 18, 0.60)";
                },
                font: function (context) {
                  if (context.tick.label === "11") {
                    return {
                      weight: "bold",
                      size: 12,
                    };
                  }
                  return {
                    weight: "normal",
                    size: 12,
                  };
                },
              },
              border: {
                display: true,
                dash: [3, 3],
                color: "rgba(0, 0, 0, 0.30)",
                width: 1,
              },
            },
          },
        },
        plugins: [createMixedValuePlugin(10), mixedPointGradientPlugin],
      });

      // ---------------------------
      // 가로 막대 차트
      // ---------------------------
      const barCtx = document.getElementById("chart-bar").getContext("2d");
      new Chart(barCtx, {
        type: "bar",
        data: {
          labels: ["1주차", "2주차", "3주차", "4주차"],
          datasets: [
            {
              label: "판매량",
              data: [12, 19, 7, 15],
              backgroundColor: function (context) {
                const chart = context.chart;
                const meta = chart.getDatasetMeta(context.datasetIndex);
                const bar = meta.data[context.dataIndex];
                return createGradient(chart.ctx, bar, gradientColors, true);
              },
              borderRadius: {
                topLeft: 0,
                topRight: 8,
                bottomLeft: 0,
                bottomRight: 8,
              },
              borderSkipped: false,
            },
          ],
        },
        options: {
          indexAxis: "y",
          responsive: true,
          plugins: { legend: { display: false } },
          scales: {
            x: {
              display: false,
              beginAtZero: true,
              grid: { color: "#eee" },
              ticks: {
                display: false,
              },
            },
            y: {
              grid: {
                drawTicks: false,
              },
              border: {
                display: false,
                dash: [3, 3],
                color: "rgba(0, 0, 0, 0.30)",
                width: 1,
              },
              ticks: {
                color: function (context) {
                  if (context.tick.label === "3주차") {
                    return "#121212";
                  }
                  return "rgba(18, 18, 18, 0.60)";
                },
                font: function (context) {
                  if (context.tick.label === "3주차") {
                    return {
                      weight: "bold",
                      size: 12,
                    };
                  }
                  return {
                    weight: "normal",
                    size: 12,
                  };
                },
              },
            },
          },
        },
        plugins: [createValuePlugin(true, 10)],
      });

      // ---------------------------
      // 라인+영역 차트
      // ---------------------------
      const lineCtx = document
        .getElementById("chart-linearea")
        .getContext("2d");

      const isCurve = false;

      // 골드 계열 포인트 그라데이션
      function goldDotGradient(context) {
        const element = context.element;
        if (!element || !element.x || !element.y || !element.radius)
          return "#C1A770";
        const { x, y, radius } = element;
        const grad = context.chart.ctx.createRadialGradient(
          x,
          y,
          0,
          x,
          y,
          radius
        );
        grad.addColorStop(0.0648, "#FAE2B0");
        grad.addColorStop(0.3914, "#C1A770");
        return grad;
      }

      // 그린 계열 포인트 그라데이션
      function greenDotGradient(context) {
        const element = context.element;
        if (!element || !element.x || !element.y || !element.radius)
          return "#249473";
        const { x, y, radius } = element;
        const grad = context.chart.ctx.createRadialGradient(
          x,
          y,
          0,
          x,
          y,
          radius
        );
        grad.addColorStop(0.0648, "#4FFFCB");
        grad.addColorStop(0.3914, "#249473");
        return grad;
      }

      // X축 하이라이트 플러그인
      const xAxisHighlightPlugin = {
        id: "xAxisHighlight",
        beforeDatasetsDraw(chart) {
          if (chart.tooltip?._active?.length) {
            const ctx = chart.ctx;
            const activePoint = chart.tooltip._active[0];
            const x = activePoint.element.x;
            const { top, bottom } = chart.chartArea;

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, bottom);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
            ctx.stroke();
            ctx.restore();
          }
        },
      };

      // 포인트 그라데이션 플러그인
      const pointGradientPlugin = {
        id: "pointGradient",
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const meta = chart.getDatasetMeta(datasetIndex);
            if (meta.type !== "line") return;

            meta.data.forEach((point, index) => {
              const { x, y } = point;
              const radius = dataset.pointRadius || 4;

              // 데이터셋별 그라데이션 색상
              let gradient;
              if (dataset.label === "판매량") {
                gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0.0648, "#FAE2B0");
                gradient.addColorStop(0.3914, "#C1A770");
              } else if (dataset.label === "매출") {
                gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0.0648, "#4FFFCB");
                gradient.addColorStop(0.3914, "#249473");
              }

              // 포인트 다시 그리기
              ctx.save();
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, 2 * Math.PI);
              ctx.fillStyle = gradient;
              ctx.fill();
              ctx.restore();
            });
          });
        },
      };

      new Chart(lineCtx, {
        type: "line",
        data: {
          labels: [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
          ],
          datasets: [
            {
              label: "판매량",
              data: [
                350, 400, 380, 450, 520, 300, 280, 1000, 490, 350, 450, 600,
              ],
              fill: true,
              backgroundColor: function (context) {
                const chart = context.chart;
                const { chartArea } = chart;

                // chartArea가 아직 없으면 기본 색상 반환
                if (!chartArea) {
                  return "rgba(145,128,80,0.3)";
                }

                const { top, bottom } = chartArea;
                const gradient = chart.ctx.createLinearGradient(
                  0,
                  top,
                  0,
                  bottom
                );
                gradient.addColorStop(0, "rgba(145,128,80,0.6)");
                gradient.addColorStop(0.8, "rgba(145,128,80,0)");
                return gradient;
              },
              borderColor: "#918050",
              borderWidth: 2,
              tension: isCurve ? 0.4 : 0,
              pointBackgroundColor: goldDotGradient,
              pointRadius: 4,
              pointHoverRadius: 6,
              order: 2, // 뒤로
            },
            {
              label: "매출",
              data: [450, 250, 280, 270, 280, 290, 300, 290, 10, 350, 320, 340],
              fill: true,
              backgroundColor: function (context) {
                const chart = context.chart;
                const { chartArea } = chart;

                // chartArea가 아직 없으면 기본 색상 반환
                if (!chartArea) {
                  return "rgba(36,148,115,0.3)";
                }

                const { top, bottom } = chartArea;
                const gradient = chart.ctx.createLinearGradient(
                  0,
                  top,
                  0,
                  bottom
                );
                gradient.addColorStop(0, "rgba(36,148,115,0.6)");
                gradient.addColorStop(0.9, "rgba(36,148,115,0)");
                return gradient;
              },
              borderColor: "#249473",
              borderWidth: 2,
              tension: isCurve ? 0.4 : 0,
              pointBackgroundColor: greenDotGradient,
              pointRadius: 4,
              pointHoverRadius: 6,
              order: 1, // 앞으로
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          interaction: {
            mode: "index",
            intersect: false,
          },
          plugins: {
            legend: { display: true },
            tooltip: {
              mode: "index",
              intersect: false,
            },
          },
          layout: {
            padding: {
              top: 50,
              bottom: 10,
              left: 30,
              right: 30,
            },
          },
          scales: {
            y: {
              beginAtZero: true,
              suggestedMax: 1200,
              ticks: {
                maxTicksLimit: 4,
              },
              grid: { color: "#eee" },
            },
            x: {
              grid: { color: "#eee" },
              border: {
                display: true,
                dash: [3, 3],
                color: "rgba(0, 0, 0, 0.30)",
                width: 1,
              },
              ticks: {
                color: function (context) {
                  if (context.tick.label === "11") {
                    return "#121212";
                  }
                  return "rgba(18, 18, 18, 0.60)";
                },
                font: function (context) {
                  if (context.tick.label === "11") {
                    return {
                      weight: "bold",
                      size: 12,
                    };
                  }
                  return {
                    weight: "normal",
                    size: 12,
                  };
                },
              },
            },
          },
        },
        plugins: [xAxisHighlightPlugin, pointGradientPlugin],
      });

      // ---------------------------
      // 도넛 차트
      // ---------------------------
      const doughnutCtx = document
        .getElementById("chart-doughnut")
        .getContext("2d");

      const totalCenterPlugin = {
        id: "totalCenter",
        beforeDraw(chart) {
          const { ctx, chartArea } = chart;
          if (!chartArea) return;

          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;

          ctx.save();
          ctx.font = "bold 24px Arial";
          ctx.fillStyle = "#333";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const total = chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
          ctx.fillText(total, centerX, centerY);
          ctx.restore();
        },
      };

      const doughnutValuePlugin = {
        id: "doughnutValuePlugin",
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          const dataset = chart.data.datasets[0];
          const meta = chart.getDatasetMeta(0);

          // 전체 합계 계산
          const total = dataset.data.reduce((a, b) => a + b, 0);

          meta.data.forEach((arc, index) => {
            const value = dataset.data[index];

            // 퍼센트 계산
            const percentage = ((value / total) * 100).toFixed(1);

            // 각도 계산
            const { startAngle, endAngle, innerRadius, outerRadius } = arc;
            const midAngle = (startAngle + endAngle) / 2;
            const angleDiff = endAngle - startAngle;

            // 영역이 작은지 확인 (10% 미만)
            const isSmallSection = value / total < 0.05;

            ctx.save();
            ctx.fillStyle = "#fff";
            ctx.font = "bold 12px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            if (isSmallSection) {
              // 작은 영역: 바깥쪽에 표시
              const lineStartRadius = outerRadius + 5;
              const lineEndRadius = outerRadius + 25;
              const textRadius = outerRadius + 35;

              const lineStartX = arc.x + Math.cos(midAngle) * lineStartRadius;
              const lineStartY = arc.y + Math.sin(midAngle) * lineStartRadius;
              const lineEndX = arc.x + Math.cos(midAngle) * lineEndRadius;
              const lineEndY = arc.y + Math.sin(midAngle) * lineEndRadius;
              const textX = arc.x + Math.cos(midAngle) * textRadius;
              const textY = arc.y + Math.sin(midAngle) * textRadius;

              // 선 그리기
              ctx.strokeStyle = "#666";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(lineStartX, lineStartY);
              ctx.lineTo(lineEndX, lineEndY);
              ctx.stroke();

              // 텍스트 표시
              ctx.fillStyle = "#333";
              ctx.fillText(percentage + "%", textX, textY);
            } else {
              // 큰 영역: 안쪽에 표시
              const radius = (innerRadius + outerRadius) / 2;
              const x = arc.x + Math.cos(midAngle) * radius;
              const y = arc.y + Math.sin(midAngle) * radius;

              ctx.fillStyle = "#fff";
              ctx.fillText(percentage + "%", x, y);
            }

            ctx.restore();
          });
        },
      };

      new Chart(doughnutCtx, {
        type: "doughnut",
        data: {
          labels: ["일반", "교육", "공공", "기타"],
          datasets: [
            {
              data: [139, 14, 12, 3],
              backgroundColor: ["#249473", "#EC8F53", "#90C9FF", "#C1A770"],
              borderWidth: 0,
            },
          ],
        },
        options: {
          responsive: true,
          plugins: { legend: { position: "bottom" } },
          cutout: "60%",
          rotation: 145,
          layout: {
            padding: {
              top: 40,
              bottom: 40,
              left: 40,
              right: 40,
            },
          },
        },
        plugins: [totalCenterPlugin, doughnutValuePlugin],
      });
    </script>
  </body>
</html>
