<!doctype html>
<html lang="ko">
  <head>
    @@include("_include/_head.html")
  </head>
  <body>
    <div class="wrap">
      @@include("_include/_header.html")
      <!-- container -->
      <div class="container">
        <section>
          <h2>세로 막대 차트</h2>
          <div>
            <canvas id="columnLine"></canvas>
          </div>
        </section>
        <section class="sales">
          <h2>라인+영역 차트</h2>
          <div>
            <canvas
              id="chart-linearea"
              style="width: 500px; height: 500px"
            ></canvas>
          </div>
        </section>
        <section>
          <h2>가로 막대 차트</h2>
          <div><canvas id="chart-bar"></canvas></div>
        </section>
        <section>
          <h2>도넛 차트</h2>
          <div>
            <canvas id="chart-doughnut"></canvas>
          </div>
        </section>
        <section></section>
      </div>
    </div>

    <script>
      // ---------------------------
      // 공통 색상 그라데이션
      // ---------------------------
      const gradientColors = [
        { stop: 0, color: "#918050" },
        { stop: 0.3399, color: "#968860" },
        { stop: 0.4981, color: "#8C7D50" },
        { stop: 1, color: "#6D5A21" },
      ];

      // ---------------------------
      // 공통: 막대 그라데이션 생성
      // ---------------------------
      function createGradient(ctx, bar, colors, isHorizontal = false) {
        if (!bar || (isHorizontal ? !bar.height : !bar.width))
          return colors[0].color;
        const gradient = isHorizontal
          ? ctx.createLinearGradient(0, bar.y, 0, bar.y + bar.height)
          : ctx.createLinearGradient(bar.x, 0, bar.x + bar.width, 0);
        colors.forEach((c) => gradient.addColorStop(c.stop, c.color));
        return gradient;
      }

      // ---------------------------
      // 공통: 값 표시 플러그인 (세로/가로 구분)
      // ---------------------------
      function createValuePlugin(isHorizontal = false, padding = 10) {
        return {
          id: "valuePlugin",
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;

            chart.data.datasets.forEach((dataset, i) => {
              const meta = chart.getDatasetMeta(i);

              meta.data.forEach((bar, index) => {
                const value = dataset.data[index];

                if (!value || value === 0) return;

                ctx.font = "bold 14px Arial";

                let xPos, yPos;

                if (isHorizontal) {
                  // 가로 막대: 막대 끝 바깥쪽에 검은색으로 표시
                  ctx.fillStyle = "#000";
                  ctx.textAlign = "left";
                  ctx.textBaseline = "middle";
                  // base는 막대의 시작점, x는 막대의 끝점
                  xPos = bar.x + padding;
                  yPos = bar.y;
                } else {
                  // 세로 막대: 막대 끝 안쪽에 흰색으로 표시
                  ctx.fillStyle = "#fff";
                  ctx.textAlign = "center";
                  ctx.textBaseline = "top";
                  xPos = bar.x;
                  yPos = bar.y + padding;
                }

                ctx.fillText(value, xPos, yPos);
              });
            });
          },
        };
      }

      // ---------------------------
      // 복합 차트용: 막대+라인 값 표시 플러그인
      // ---------------------------
      function createMixedValuePlugin(padding = 10) {
        return {
          id: "mixedValuePlugin",
          afterDatasetsDraw(chart) {
            const ctx = chart.ctx;
            chart.data.datasets.forEach((dataset, i) => {
              const meta = chart.getDatasetMeta(i);

              meta.data.forEach((element, index) => {
                const value = dataset.data[index];
                if (!value || value === 0) return;

                ctx.font = "bold 12px Arial";
                ctx.textAlign = "center";

                let xPos, yPos;

                // 막대 차트인 경우
                if (dataset.type === "bar") {
                  ctx.fillStyle = "#000"; // 막대는 검은색
                  ctx.textBaseline = "bottom";
                  xPos = element.x;
                  yPos = element.y - padding;
                }
                // 라인 차트인 경우
                else if (dataset.type === "line") {
                  ctx.fillStyle = "#FF5C00"; // 라인은 오렌지색
                  ctx.textBaseline = "top";
                  xPos = element.x;
                  yPos = element.y - padding - 5; // 라인 포인트 위쪽
                }

                ctx.fillText(value, xPos, yPos);
              });
            });
          },
        };
      }

      // 복합 차트용 포인트 그라데이션 플러그인 (보더 추가)
      const mixedPointGradientPlugin = {
        id: "mixedPointGradient",
        afterDatasetsDraw(chart) {
          const ctx = chart.ctx;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const meta = chart.getDatasetMeta(datasetIndex);
            if (dataset.type !== "line") return;

            meta.data.forEach((point, index) => {
              const { x, y } = point;
              const radius = dataset.pointRadius || 4;

              // -----------------------------------------------------
              // ✨ CSS 스타일을 캔버스 API로 변환 (기존 그라데이션 로직)
              // -----------------------------------------------------
              const gradCenterX = x - radius + 2 * radius * 0.3333;
              const gradCenterY = y - radius + 2 * radius * 0.3333;
              const outerRadius = radius * 0.7862;

              const gradient = ctx.createRadialGradient(
                gradCenterX,
                gradCenterY,
                0,
                gradCenterX,
                gradCenterY,
                outerRadius
              );

              gradient.addColorStop(0.1475, "#FFBB89");
              gradient.addColorStop(0.5805, "#E5690D");
              gradient.addColorStop(0.9277, "#AE3607");
              // -----------------------------------------------------

              // 포인트 다시 그리기
              ctx.save();
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, 2 * Math.PI);

              // 1. 그라데이션 채우기
              ctx.fillStyle = gradient;
              ctx.fill();

              // 2. ✨ 흰색 반투명 보더(Border) 그리기
              ctx.strokeStyle = "rgba(255, 255, 255, 0.8)"; // 흰색, 70% 투명도
              ctx.lineWidth = 2; // 보더 두께 (원하는 두께로 조절)
              ctx.stroke(); // 보더 그리기

              ctx.restore();
            });
          });
        },
      };

      // ---------------------------
      // 세로 막대 + 라인 차트 (복합)
      // ---------------------------
      const mixedCtx = document.getElementById("columnLine").getContext("2d");

      new Chart(mixedCtx, {
        type: "bar",
        data: {
          labels: [
            "1",
            "2",
            "3",
            "4",
            "5",
            "6",
            "7",
            "8",
            "9",
            "10",
            "11",
            "12",
          ],
          datasets: [
            {
              type: "bar",
              label: "판매량",
              data: [
                300, 400, 350, 450, 500, 320, 280, 600, 490, 350, 450, 520,
              ],
              backgroundColor: function (context) {
                const chart = context.chart;
                const meta = chart.getDatasetMeta(context.datasetIndex);
                const bar = meta.data[context.dataIndex];
                return createGradient(chart.ctx, bar, gradientColors);
              },
              borderRadius: {
                topLeft: 2,
                topRight: 2,
                bottomLeft: 0,
                bottomRight: 0,
              },
              borderSkipped: false,
              yAxisID: "y",
              order: 2, // 막대를 뒤로
            },
            {
              type: "line",
              label: "매출",
              data: [
                250, 380, 320, 420, 480, 300, 260, 580, 470, 330, 430, 500,
              ],
              borderColor: "#FF5C00",
              backgroundColor: "rgba(36,148,115,0.1)",
              borderWidth: 2,
              tension: 0,
              pointBackgroundColor: function (context) {
                const element = context.element;
                if (!element || !element.x || !element.y || !element.radius)
                  return "#249473";
                const { x, y, radius } = element;
                const grad = context.chart.ctx.createRadialGradient(
                  x,
                  y,
                  0,
                  x,
                  y,
                  radius
                );
                grad.addColorStop(0.0648, "#4FFFCB");
                grad.addColorStop(0.3914, "#249473");
                return grad;
              },
              pointRadius: 4,
              pointHoverRadius: 6,
              yAxisID: "y",
              order: 1, // 라인을 앞으로
            },
          ],
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: true },
            tooltip: { enabled: true },
          },
          scales: {
            y: {
              beginAtZero: true,
              grid: { color: "#eee" },
              ticks: {
                color: "rgba(18, 18, 18, 0.60)",
              },
            },
            x: {
              grid: {
                drawTicks: false,
              },
              ticks: {
                color: function (context) {
                  if (context.tick.label === "11") {
                    return "#121212";
                  }
                  return "rgba(18, 18, 18, 0.60)";
                },
                font: function (context) {
                  if (context.tick.label === "11") {
                    return {
                      weight: "bold",
                      size: 12,
                    };
                  }
                  return {
                    weight: "normal",
                    size: 12,
                  };
                },
              },
              border: {
                display: true,
                dash: [3, 3],
                color: "rgba(0, 0, 0, 0.30)",
                width: 1,
              },
            },
          },
        },
        plugins: [createMixedValuePlugin(10), mixedPointGradientPlugin],
      });
    </script>
  </body>
</html>
